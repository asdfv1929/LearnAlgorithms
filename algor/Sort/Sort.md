# 选择排序
基本思想：
- 找到数组中最小的元素
- 将该最小元素与数组中的第一个元素交换位置（若第一个元素即为最小元素，则自己与自己交换）
- 在剩下的元素中找到最小的元素，与数组中的第二个元素交换位置
- 如此反复，直至整个数组排序完成

每次交换都能排定一个元素，因此交换的总次数为N，所以算法的时间效率取决于比较的次数。
对于长度为N的数组，选择排序需要N次交换和N^2/2次比较：
- i = 0, 比较 N-1 次（第一个元素作为待比较值，与其他元素进行比较，选出最小值）
- i = 1, 比较 N-2 次
- ...
- i = i, 比较 N-1-i 次
- ...
- i = N-2, 比较 1 次
- 比较次数求和：N(N-1)/2


特点：
- 运行时间和输入无关：不论数组元素是否基本有序，均需要遍历比较、交换
- 数据移动次数最少：每次交换只改变两个数组元素的值，N次交换，交换次数和数组的大小是线性关系


# 插入排序
插入排序所需时间取决于数组元素的初始顺序
- 最好情况，为元素已序，遍历时当前元素与前面已序数组中最后一个元素进行比较，发现当前元素比待比较元素大，则无需进行元素交换。因此，需要 N-1 次比较和 0 次交换
- 最坏情况，为元素逆序，遍历时当前元素要比已序数组中的所有元素都要小，所以需要与已序数组中所有元素需要比较，在插入时进行移动位置。
    - 从第2个元素开始，和前面已序数组进行比较：第2个元素需要比较 1 次，第3个元素需要2次，第i个元素需要 i-1 次，第N个元素需要 N-1 次。因此总共需要 N(N-1)/2 次比较
    - 每次比较完后，均需要位置交换，因此总共需要 N(N-1)/2 次交换
- 平均情况，元素位置基本随机，N^2/4 次比较，N^2/4 次交换

优化插入排序：在内循环中将较大的元素都向右移动而不总是交换两个元素


# 希尔排序
基于插入排序的快速的排序算法    
希尔排序交换不相邻的元素以对数组的局部进行排序，并最终使用插入排序将局部有序的数组排序。    
基本思想：使数组中任意间隔为h的元素都是有序的。

# 归并排序
基本思想：递归地将输入数组分成两半分别排序     

改进：
- 对小规模子数组使用插入排序
- 测试数组是否已经已序
- 不将元素复制到辅助数组

三向归并

# 快速排序
分治思想    
- 选取首个元素为切分元素
- 两个指针i,j，一个从左到右扫描比切分元素大的元素，一个从右到左扫描比切分元素小的元素
- 交换两指针各自扫描到的元素位置
- 继续扫描下去，直至完成。最后交换切分元素和最后的扫描点位置元素，此时完成切分元素左侧均小于它，右侧均大于它
- 递归调用排序，对数组左半部分和右半部分继续划分

# 三向切分的快速排序
- 三个指针，lt/i/gt，lt指向数组左侧元素，从左到右遍历，gt指向右侧元素，从右到左遍历，i从第二个元素开始遍历
- array[i]遍历，若array[i]小于切分元素，则array[i]和array[lt]交换位置，两指针右移
- 若array[i]大于切分元素，则array[i]和array[gt]交换位置，gt指针左移，i不变（将大于切分元素的元素右移，
交换后i指向的新元素尚未与切分元素比较，因此i不变，保证该新元素与切分元素进行比较）
- 若相等，则不发生交换，i指针右移

# 堆排序
TODO
测试
