# 基于无序链表的顺序查找

# 基于有序数组的二分查找

# 二叉查找树
一颗二叉查找树（BST）是一颗二叉树，其中每个结点都含有一个Comparable的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。
size(x) = size(x.left) + size(x.right) + 1

# 平衡查找树
## 2-3树
一颗标准的二叉查找树种的结点称为2-结点（含有一个键和两条链接）。    
引入3-结点（两个键和三条链接）    
一颗2-3查找树或为一颗空树，或由以下结点组成：
- 2-结点，含有一个键和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树种的键都大于该结点
- 3-结点，含有两个键和三条链接，左链接指向2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向2-3树中的键都大于该结点

在一棵大小为N的2-3树中，查找和插入操作访问的结点必然不超过lgN个。

1）查找
- 判断一个键是否在树中，先将它和根结点中的键比较
- 若它和其中任意一个相等，则查找命中
- 否则就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归继续查找
- 若是空链接，则查找未命中

2）向2-结点插入新键   
先进行一次未命中的查找，然后把新结点挂在树的底部。
若未命中的查找结束于一个2-结点，则只要把这个2-结点替换为一个3-结点：将要插入的键保存在其中即可。

3）向一棵只含有一个3-结点的树中插入新键    
插入新键，临时将新键存入树中唯一的结点中，使之成为一个4-结点（3个键和4条链接）。    
将该4-结点转换为一棵由3个2-结点组成的2-3树。   

4）向一个父结点为2-结点的3-结点中插入新键    
在维持树的完美平衡的前提下为新键腾出空间。    
将插入新键后的4-结点中的中键插入到父节点中，并指向左右键

5）向一个父结点为3-结点的3-结点插入新键    
成为4-结点，将中键插入到父结点中，左右键变为该父结点的两条链路下结点。    
父结点变为4-结点，继续讲中键插入到它的父结点上，左右键变为父结点的两条链路下结点。
不断向上插入，直至遇到一个2-结点并将它替换为一个不需要继续分解的3-结点，或者是到达3-结点的根。

6）分解根结点   
如果从插入结点到根结点的路径上全都是3-结点，根结点最终变成一个临时的4-结点。此时可按照向一棵只有一个3-结点的树中插入新键的方法处理该问题。
将临时的4-结点分解为3个2-结点，使得树高加1。

7）局部变换
将一个4-结点分解为一颗2-3树可能有6种情况：这个4-结点可能是根结点，可能是一个2-结点的左子结点或者右子结点，也可能是一个3-结点的左子结点、中子结点或右子结点。

## 红黑树

